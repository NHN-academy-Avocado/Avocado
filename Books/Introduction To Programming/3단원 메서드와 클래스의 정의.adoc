== 3단원: 메서드와 클래스의 정의

=== 3.1 모듈화(Modularization)

==== 프로그램은 매우 길고 복잡할 수 있다. 복잡성을 관리하기 위해, 모듈 방식으로 프로그램을 구현할 필요가 있습니다.

* 프로그램은 모듈이라 불리는 독립된 부분으로 구조화되어야 합니다.
* 다양한 모듈들은 정밀한 관계를 통해 서로 연관되어 있습니다.

==== 모듈의 특징으로는:

* 클라이언트에 제공되는 서비스(이것들은 해당 서비스를 사용하는 다른
  모듈들입니다.)
* 인터페이스. 즉, 이러한 서비스가 내보내지는 방식입니다.
* 불려진 서비스. 즉 모듈이 클라이언트인 서비스입니다.
* 내부 구조. 즉, 모듈이 실현되는 방식; 내부 구조는 클라이언트에게
  중요하지 않다.

==== 모듈화의 사용을 통해 우리는 프로그램을 다음과 같이 실현할 수 있습니다:

[arabic]
. 우리는 요청된 문제를 해결하기 위해 어떤 모듈이 필요한지를 정의합니다.
. 우리는 이러한 모듈이 서로 어떻게 관련되어 있는지를 정의합니다.
. 우리는 각 모듈을 다른 모듈들과 독립적으로 개발합니다.

==== 이렇게 진행함으로써 우리는 프로그램의 여러 가지 품질을 향상시키며 프로그램을 다루기를 단순화할 수 있습니다.특히:

* 프로그램의 가독성(또는 이해가능성)
* 확장성(즉, 필요한 경우 프로그램의 기능을 확장할 수 있는 가능성)
* 다양한 목적으로 프로그램의 일부를 재사용할 수 있음

=== 3.2 추상화(Abstraction)

==== _모듈화는 추상화_ 개념과 밀접하게 결합되어 있습니다

* 우리가 식별한 솔루션을 기반으로 문제의 추상적인 모델을 구축합니다
  ** 우리는 문제의 본질적인 측면에 초점을 맞춥니다.
  ** 우리는 달성하려는 목표와 관련이 없는 측면을 무시합니다.
* • 추상적인 모델에 상응하는 구체적인 모델을 선택하고, 이를 통해 문제의
  해결을 실현합니다.

==== 추상화 유형:

* 작업에 대한 추상화: 특정 작업이 "무엇(what)"을 수행해야 하는지에
  집중하고, 그 작업을 "어떻게(how)" 수행하는지에 대해서는 신경 쓰지
  않습니다.
* 객체에 대한 추상화:
  ** 유사한 객체(즉, 동일한 속성을 가진 객체)를 클래스로 그룹화합니다.
  ** 우리는 객체의 관련 속성을 설정하고 특히 객체가 지원하는 작업을
  확인합니다 (이는 작업에 대한 추상화를 필요로 합니다).

=== 3.3 작업에 대한 추상화: 메서드

작업에 대한 추상화는 현재 모든 프로그래밍 언어(Java, C#, C++, C, Pascal,
Fortran, Lisp 등)에서 지원됩니다.

Java에서는 작업에 대한 추상화가 메서드 개념을 통해 실현됩니다 . 메서드는
매개변수를 입력으로 사용하고 결과를 반환하거나 일부 작업을 수행하는
블랙박스로 간주될 수 있습니다.

image:https://github.com/NHN-academy-Avocado/Avocado/assets/80580473/27aeabec-3f23-4bef-bc8a-ff2d0dce3046[Untitled]
## 3.4 모듈로 보는 methods

모듈로 표시되는 메서드의 특징은:

* 내보내진 서비스: 메서드가 ``무엇''을 인식하는지
* _인터페이스_ : 메서드 헤더(입력 매개변수 및 결과(있는 경우)의 유형을
  지정함)
* 내보내진 서비스(오타 임포디드 서비스): 해당 메서드를 구현하는데 사용된
  메서드나 클래스들
* 내부 구조: 실현하는 ``무엇''을 구현하는 메서드의 ``어떻게''를 설명하는
  자바 코드 (이것은 메서드를 호출하는 클라이언트에게는 관심이 없습니다.)

=== 3.5 정적 메서드의 정의

Java에서 가장 간단한 형태의 메서드는 *정적* 메서드 입니다 .

정적 메서드는 호출 개체가 _없는_ 메서드(클래스에 정의됨)입니다 .

==== 구문:

헤더 블럭

* _헤더_ 는 정적 메서드의 헤더이며 다음과 같은 형식을 갖습니다.
+
[source,java]
----
public static resultType methodName(formalParameters)
----
** public : 정의되는 메서드가 클래스 외부에서 액세스 가능함을 나타냅니다
** static : 메서드가 정적임을 나타냅니다(즉, 호출 객체가 없음).
** resultType : method가 반환한 결과의 타입, 메서드가 어떤 결과도
반환하지 않는 경우에는 void입니다.
** methodName : 메서드의 이름
** formalParameters : 쉼표로 구분된 매개변수 선언(타입 및 이름)
목록입니다. 각 매개변수는 변수이며, 매개변수 목록은 비어있을 수도
있습니다.
* 블럭은 메서드가 호출될 때 실행될 명령문을 포함하는 메서드의
  본문입니다. 다음과 같은 형식을 갖습니다.
+
[source,java]
----
{
    statements
}
----
** 의미론: 헤더와 본문을 지정하여 정적 메서드를 정의합니다.
* 헤더는 나타냅니다:
  ** 메서드 이름,
  ** 형식 매개변수의 수와 타입
  ** 리턴된 값의 타입(있는 경우)
  ** 메서드가 정의된 클래스 외부에서 메서드에 대한 접근성.
* 메서드의 본문은 메서드가 호출될 때 실행되어야 하는 명령문을
  지정합니다.
* 형식 매개변수는 메서드 본문에 사용되는 객체 또는 더 일반적으로 정보를
  전달하는 데 사용됩니다.
+
형식 매개변수는 초기화된 변수와 동일한 방식으로 메서드 본문 내에서
사용됩니다(초기화는 메서드가 호출되는 순간 각 형식 매개변수에 해당 실제
매개변수의 값을 할당하여 수행됩니다.)
* 반환된 결과는 메서드 호출의 값입니다. 메서드가 결과를 반환하지 않으면
  결과를 계산하는 데 사용되어서는 안 되며 형식 매개변수로 표시된 개체에
  부작용을 수행하는 데 사용해야 합니다.

얘)

이전에 사용된 정적 메서드 main 입니다 . 이러한 방법은 항상 다음과 같은
형식을 갖습니다.

[source,java]
----
public static void main(String[] args){
    ...
}
----

메인 메서드의 헤더는 다음을 보여줍니다:

* 클래스가 정의된, 밖에서 엑세스할 수 있는 메서드
* 이는 정적 메서드( static )입니다.
* 결과를 반환하지 않습니다(반환 유형은 void ).
* 이는 문자열 배열 유형의 매개변수를 갖습니다(유닛 7 참조). 지금까지
  우리 프로그램에서는 이 매개변수를 사용한 적이 없습니다.

=== 3.6 정적 메서드의 정의의 예

ex 1)

[source,java]
----
public static void printGtreeting(){
    System.out.println("Good morning!");
}
----

printGreeting 메소드는 공식적인 매개변수가 없고 결과를 반환하지 않는
정적 공용 메소드입니다(헤더 참조).

본문은 ``Good morning!'' 이라는 문자열을 인쇄하는 단일 문으로
구성됩니다.

ex 2):

[source,java]
----
public static void printPersonalGreeting(String firstName, String lastName) {
System.out.print("Good morning ");
  System.out.print(firstName);
  System.out.print(" ");
  System.out.print(lastName);
  System.out.println("!");
}
----

printPersonalGreeting 메소드는 String 유형의 두 가지 형식
매개변수 firstName 및 lastName을 갖고 어떤 결과도 반환하지 않는 정적
공개 메소드입니다 (헤더 참조)

본문은 각각 "Good morning!" 이라는 문자열을 인쇄하는 일련의 명령문으로
구성됩니다. , 형식 매개변수 firstName 의 값 , 공백, 형식
매개변수 lastName 의 값 , 마지막으로 문자열 "!" .

형식 매개변수는 이미 초기화된 지역 변수와 동일하게 메소드 본문 내에서
사용됩니다.

ex 3) 이름을 나타내는 문자열을 입력으로 받아 "Ciao" 문자열과
매개변수로 전달된 이름, "!" 문자열을 인쇄하는 정적
메소드 printInformalGreeting 을 구현합니다.

[source,java]
----
public static void printInformalGreeting (String name) {
    System.out.println("Ciao " + name + "!");
}
----

=== 3.7 메소드의 결과: return 문

메소드가 결과를 반환해야 하는 경우 return 문을 포함해야 합니다.

return 문이 메서드 내에서 실행 되면 메서드가 종료되고 그 결과가
클라이언트 모듈(즉, 메서드가 호출된 프로그램 부분)에 반환됩니다.

return 문의 구문은 다음과 같습니다.

[source,java]
----
return expression;
----

여기서 _표현식은_ 값이 메소드 헤더에 선언된 결과 타입과 호환되는
표현식이어야 합니다.

ex)

[source,java]
----
public static String personalGreeting(String firstName, String lastName) {
    return "Good morning " + firstName + " " + lastName + "!";
}
----

결과 유형이 void 인 경우 return 문 을 생략하거나 단순히 메서드 실행을
중단하는 데 사용할 수 있습니다. 이 경우 결과를 반환할 필요가 없으므로 이
경우 구문은 다음과 같습니다.

[source,java]
----
return;
----

_참고:_ 뒤에 추가 명령이 있더라도 return 문을 실행하면 항상 메서드가
종료됩니다.

=== 3.8 동일한 클래스에서 정의된 정적 메소드 사용의 예

다음 프로그램은 동일한 클래스에 정의된 정적 메서드의 사용을 보여줍니다.

[source,java]
----
import javax.swing.JOptionPane;
public class Program1 {
public static void printGreeting() {
System.out.println("Good morning!");
}

    public static void printPersonalGreeting(String firstName, String lastName) {
        System.out.print("Good morning ");
        System.out.print(firstName);
        System.out.print(" ");
        System.out.print(lastName);
        System.out.println("!");
    }

    public static void printInformalGreeting(String name) {
        System.out.println("Ciao " + name + "!");
    }

    public static String personalGreeting(String firstName, String lastName) {
        return "Good morning " + firstName + " " + lastName + "!";
    }

    public static void main(String[] args) {
        printGreeting();
        String fn = JOptionPane.showInputDialog("First name");
        String ln = JOptionPane.showInputDialog("Last name");
        printPersonalGreeting(fn, ln);
        printInformalGreeting(fn);
        JOptionPane.showMessageDialog(null, personalGreeting(fn, ln));
        System.exit(0);
    }
}
----

_참고:_ Program1 클래스에 정의된 정적 메서드는 앞에 클래스 이름을 붙이지
않고 Program1 의 기본 메서드 에 의해 호출됩니다 . 이는 메소드가 main 과
동일한 클래스에 속하기 때문에 가능합니다 .

=== 3.9 다른 클래스에서 정의된 정적 메소드 사용의 예

이제 동일한 메서드를 다른 클래스로 그룹화해 보겠습니다.

[source,java]
----
public class Greetings {
public static void printGreeting() {
System.out.println("Good morning!");
}

    public static void printPersonalGreeting(String firstName, String lastName) {
        System.out.print("Good morning ");
        System.out.print(firstName);
        System.out.print(" ");
        System.out.print(lastName);
        System.out.println("!");
    }

    public static void printInformalGreeting(String name) {
        System.out.println("Ciao " + name + "!");
    }

    public static String personalGreeting(String firstName, String lastName) {
        return "Good morning " + firstName + " " + lastName + "!";
    }
}
----

클라이언드의 예)

[source,java]
----
import javax.swing.JOptionPane;

public class GreetingsClient {
    public static void main(String[] args) {
      Greetings.printGreeting();
      String fn = JOptionPane.showInputDialog("First name");
      String ln = JOptionPane.showInputDialog("Last name");
      Greetings.printPersonalGreeting(fn, ln);
      Greetings.printInformalGreeting(fn);
      JOptionPane.showMessageDialog(null, Greetings.personalGreeting(fn, ln));
      System.exit(0);
    }
}
----

Client의 main 메소드에서 정적 메소드에 대한 호출 앞에 해당 메소드가
정의된 클래스의 이름을 추가해야 합니다.

_참고:_ Greetings 클래스는 다양한 인사말 기능을 구현하는
간단한 *라이브러리* 로 간주될 수 있습니다 . 나중에 함수를 실현하는 정적
메서드로 구성된 실수에서 가장 일반적으로 사용되는 수학 함수 라이브러리인
사전 정의된 클래스 Math를 살펴보겠습니다 .

=== 3.10 파라미터 전달

말했듯이, 메소드 정의에는 헤더에 *형식 매개변수* 목록이 포함되어
있습니다 . 이러한 매개변수는 메소드 본문 내부의 변수와 동일한 방식으로
사용됩니다.

메소드 호출에는 메소드의 인수로 사용해야 하는 매개변수가
포함됩니다. 이러한 매개변수를 메소드 정의의 헤더에 나타나는 형식
매개변수와 구별하기 위해 *실제 매개변수* 라고 합니다 .

메소드를 호출하여 *활성화* 할 때 실제 매개변수를 형식
매개변수에 _바인딩_ 해야 합니다 . 일반적으로 이러한 바인딩을 설정하는
방법에는 여러 가지가 있습니다. _Java에는 값에 의한 호출( call by
value)_ 이라는 한 가지 방법만 있습니다 .

pa를 메서드 호출의 실제 매개 변수로 두고, pf 를 메서드 정의 헤더의 해당
형식 매개 변수로 둡니다. 값으로 pa를 pf 에 바인딩한다는 것은 메서드가
활성화될 때 다음을 수행한다는 의미입니다.

[arabic]
. 실제 매개변수 pa가 계산됩니다( pa는 일반적으로 표현식이라는 점에
유의하세요).
. 메모리 위치는 형식 매개변수 pf 와 연관되어 있습니다.
. pf 값 (즉, 해당 메모리 위치)은 pa 에 대해 계산된 값으로 초기화됩니다 .

즉, 형식 매개변수 pf는 메소드가 호출되는 순간 생성된 지역 변수와 정확히
동일하게 작동하고 해당 실제 매개변수 pa 의 값으로 초기화됩니다 .

메서드 본문 실행이 끝나면 형식 매개변수에 예약된 메모리 위치가 해제되고
여기에 저장된 값이 손실됩니다.

_참고:_ pa 표현식에 나타나는 변수 값은 메서드 실행으로 변경되지
않습니다. 그러나 그러한 값이 개체에 대한 참조인 경우 메서드는 실제로
참조로 표시된 개체를 변경할 수 있습니다(나중에 참조).

다음 그림은 매개변수가 객체에 대한 참조인 경우 매개변수 전달의 예를
보여줍니다. 기본 데이터 유형인 매개변수의 경우는 단원 4에서 설명합니다.

다음 그림은 매개변수가 객체에 대한 참조인 경우 매개변수 전달의 예를
보여줍니다. 기본 데이터 유형인 매개변수의 경우는 단원 4에서 설명합니다.

image::https://github.com/NHN-academy-Avocado/Avocado/assets/80580473/65dad77b-385e-419a-97fb-f4b5b66a466b[Untitled1]

=== 3.11 메소드의 실행

다음 메서드 정의를 고려하세요.

[source,java]
----
public static String duplicate(String pf) {
    return pf + ", " + pf;
}
----

그런 다음 다음 주요 방법을 고려하십시오.

[source,java]
----
public static void main(String[] args) {
  String s;
  s = duplicate("pippo" + "&" + "topolino");
  System.out.println(s);
}
----

중복 메소드 에 대한 호출이 포함된 명령문이 실행될 때 어떤 일이
발생하는지 자세히 분석해 보겠습니다.

[arabic]
. _실제 매개변수가 실행됩니다._
+
우리의 경우 실제 매개변수는 값이 "pippo & topolino" 문자열인 "pippo"
+ "&" + "topolino " 표현식입니다 .
  . _실행될 메소드는_ 메소드의 이름과 실제 매개변수의 개수 및 타입을
  고려하여 결정됩니다. 메소드 호출에 해당하는 시그니처가 있는 메소드를
  찾아야 합니다. 메소드 이름은 호출의 이름과 동일해야 하며 형식
  매개변수(예: 해당 번호 및 유형)는 실제 매개변수와 일치해야 합니다.
+
우리의 경우, 우리가 찾고 있는 메소드는 반드시 copy (String) 시그니처를
가지고 있어야 합니다 .
. _호출 프로그램 단위의 실행이 일시 중지됩니다._
+
우리의 경우에는 main 메소드입니다 .
. 메모리 는 형식 매개변수(변수로 간주됨)와 메서드에 정의된 변수(나중에
참조)에 _할당됩니다 ._
+
우리의 경우에는 형식 매개변수 pf 에 메모리가 할당됩니다 .
. _각 형식 매개변수는 해당 실제 매개변수의 값으로 초기화됩니다._
+
우리의 경우 형식 매개변수 pf는 ``pippo&topolino'' 문자열을 나타내는
객체에 대한 참조로 초기화됩니다 .
. _호출된 메서드라 불리는 본문의_ 첫 번째 문부터 실행됩니다.
. _호출된 메서드의 실행이 종료됩니다_ (return 문이 실행되거나 더 이상
실행할 문이 없기 때문에).
+
우리의 경우 명령문은 pf + ``,'' + pf를 반환합니다. 실행됩니다.
. _형식 매개변수와 지역 변수에 대한 메모리가 해제되고,_ 여기에 포함된
모든 정보가 손실됩니다.
+
우리의 경우 형식 매개변수 pf 에 해당하는 메모리 위치가 해제됩니다.
. _메소드가 결과를 반환하는 경우,_ 결과는 호출 프로그램 단위에서 메소드
호출에 의해 반환된 표현식의 값이 됩니다.
+
우리의 경우 결과는 ``pippo&topolino, pippo&topolino'' 입니다 .
. _호출 유닛의 실행은_ 메서드 호출에 의해 일시 중단된 지점부터
계속됩니다.
+
우리의 경우 ``pippo&topolino, pippo&topolino'' 값이 변수 s 에 할당됩니다
.

=== 3.12 메소드에 의해 수행된 객체 수정

다음 프로그램은 객체에 대한 참조인 매개변수를 전달할 때 어떤 일이
발생하는지 보여줍니다.

[source,java]
----
public class Parameters {
public static void changeValueS(String s) {
s = s.concat("*");
}

    public static void changeValueSB(StringBuffer sb) {
        sb.append("*");
    }

    public static void main(String[] args) {
        String a = "Hello";
        StringBuffer b = new StringBuffer("Ciao");
        System.out.println("String a = " + a);
        System.out.println("StringBuffer b = " + b);
        changeValueS(a);
        changeValueSB(b);
        System.out.println("String a = " + a);
        System.out.println("StringBuffer b = " + b);
    }
}
----

프로그램 실행 결과는 다음과 같습니다.

[source,java]
----
String a = Hello
StringBuffer b = Ciao
String a = Hello
StringBuffer b = Ciao*
----

실제 매개변수 a 와 b 는 상응하는 형식 매개변수 s 와 sb 에 값으로
바인딩되므로 해당 값(즉, 객체에 대한 참조)은 메서드 실행으로 수정되지
않습니다. 그러나 이것이 참조하는 개체의 상태가 변경될 수 없다는 의미는
아닙니다(예제 참조).

b 가 참조하는 객체의 상태가 변경되는 이유는 a 의 경우에는 그렇지 않지만
매개변수 전달의 직접적인 결과는 아닙니다(매개변수는 a 및 b 에 대해
동일한 방식으로 전달된다는 점에 유의하세요 ). 변경 사항은 호출된 객체의
상태를 수정하는 Append 메소드 의 사용에 따라 달라집니다 (예: sb 는 b 와
동일한 객체를 참조하는 반면 concat 메소드는 객체 s 의 상태를 수정하지
않습니다. , 따라서 a ).

image::https://github.com/NHN-academy-Avocado/Avocado/assets/80580473/e2c203ff-6c7b-45ba-934d-43d1c259cd22[Untitled2]

=== 3.13 지역변수

메소드의 본문에는 변수 선언이 포함될 수 있습니다. _이러한 변수를 지역
변수_ 라고 합니다 . 사실 지금까지 우리가 사용했던 모든 변수는 메소드의
몸체, 즉 메인 메소드 에서 선언되었기 때문에 지역 변수였습니다 . 따라서
Unit 2에서 본 것처럼 사용됩니다.

여기서는 두 가지 근본적인 측면에 중점을 둡니다.

* *scope* (정적 개념, 즉 프로그램 텍스트에 따라 다름)
* *lifetime* (동적 개념, 즉 프로그램 실행에 따라 다름)

_참고:_ Java에서는 클래스에 대한 _전역 변수를_ 정의하는 것도 가능합니다
. 전역 변수는 클래스 내부에 정의되지만 메서드 외부에
정의되며 static 으로 규정됩니다 . 이 과정에서는 전역 변수를 사용하지
않습니다.

=== 3.14 지역범수의 범위

변수의 범위 *는* _변수가 표시되는 프로그램 영역_ , 즉 변수 이름으로
액세스할 수 있고 사용할 수 있는 영역입니다.

Java에서 지역 변수의 범위는 해당 변수가 선언된 메서드의 본문입니다. 즉,
변수는 해당 선언이 나타나는 메서드 본문에 표시되지만 메서드 외부에는
표시되지 않습니다.

명히, 2단원에서 이미 말했듯이, 변수가 선언되기 전에는 메서드 본문에서
변수를 사용할 수 없습니다.

참조

* 실제로 더 일반적인 범위 규칙이 적용됩니다. 즉, 지역 변수의 범위는 선언
  지점부터 이를 둘러싸는 블록 끝까지 확장됩니다. 블록 _은_ \{…} 형식의
  명령문입니다 (나중에 참조). 따라서 지역 변수는 선언된 블록(있는 경우
  하위 블록 포함)에서 볼 수 있지만 해당 블록 외부에서는 볼 수 없습니다.
* Java에서 변수의 범위는 완전히 정적 개념입니다. 실제로 프로그램의
  실행을 고려하지 않고 프로그램의 구조를 분석하여 결정할 수
  있습니다. _대부분의 최신 프로그래밍 언어는 이러한 정적 범위_ 개념을
  지원합니다 .
* 다음과 같은 경우 범위 개념은 _컴파일 타임에 관련_ 됩니다 .

=== 3.15 지역변수의 범위의 예

다음 프로그램을 고려해보세요.

[source,java]
----
public class Visibility {
    public static String duplicate(String s) {
      String t = s + ", " + s;
        return t;
    }

    public static void print1() {
        System.out.println(a); // ERROR: a is not defined
    }

    public static void print2() {
        System.out.println(t); // ERROR: t is not defined
    }

    public static void main(String[] args) {
        String a = "Ciao";
        a = duplicate(a);
        print1();
        print2();
        System.out.println(a);
    }
}
----

프로그램을 컴파일하는 동안 컴파일러는 두 가지 오류 신호를 보냅니다.

[arabic]
. print1 메소드 에서 변수 a는 표시되지 않습니다( 기본 메소드 에 정의되어
있으므로 ).
. print2 메소드 에서는 변수 t가 표시되지 않습니다( duplicate 메소드 에
정의되어 있으므로 ).

=== 3.16 지역변수의 lifetime

변수의 수명 *은* _변수가 메모리에 유지되어 프로그램 실행 중에 액세스할
수 있는 시간_ 입니다 .

메소드에 로컬인 변수는 메소드가 활성화되는 순간(정확히 형식 매개변수로)
생성되고 메소드 활성화가 종료되면 소멸됩니다.

보다 정확하게는 메서드가 활성화되면 _활성화 레코드_ 라고 하는 메모리 셀
블록 이 할당됩니다. 여기에는 현재 메서드 호출의 모든 지역 변수와 형식
매개변수가 포함됩니다. 활성화 레코드는 메서드 실행 중에 사용되며 실행이
끝나면 제거됩니다. 활성화 레코드가 제거되면 지역 변수와 형식 매개변수의
메모리 위치가 삭제되고 여기에 포함된 값도 손실됩니다.

메서드가 다시 활성화되면 이전 활성화와 아무 관련이 없는 새 메모리 위치를
포함하는 새 활성화 레코드가 할당됩니다. 따라서 각 메서드 활성화 시 지역
변수 및 형식 매개변수에 대한 메모리 위치가 새로 생성되며 이러한 메모리
위치는 일반적으로 이전 활성화의 메모리 위치와 다릅니다. 따라서 지역
변수와 형식 매개변수의 값은 한 메소드 호출에서 다음 메소드
호출까지 *유지되지 않습니다 .*

_참고:_ 변수의 수명 개념은 _실행 시간과 관련이_ 있습니다 .

=== 3.17 메소드 오버로딩

앞서 말했듯이 Java는 이름뿐만 아니라 전체 시그니처를 기준으로 메서드를
구별합니다. 따라서 이러한 메서드가 형식 매개변수의 수나 유형이 다른 한
동일한 클래스에서 동일한 이름을 가진 두 개 이상의 메서드를 정의할 수
있습니다(참고: 형식 매개변수의 이름은 구별과 관련이 없습니다). 이 기능을
메서드 _오버로드_ 라고 합니다 .

예)

[source,java]
----
public class Greetings2 {
    public static void printGreeting() {
     System.out.println("Hello!");
    }

    public static void printGreeting(String name) {
        System.out.println("Hello " + name + "!");
    }
}
----

* 실제 매개변수 없이 printGreeting 메소드를 호출하면 첫
  번째 printGreeting 메소드(공식 매개변수가 없는
  메소드)가 활성화되어 ``Hello!''라는 문자열이 인쇄됩니다.
* String 유형의 실제 매개변수 하나를 사용하여 printGreeting 메소드를
  호출 하면 두 번째 printGreeting 메소드가 활성화됩니다. 이
  메소드는 "Hello" 문자열과 매개변수로 전달된
  문자열, "!"를 인쇄합니다.

=== 3.18 객체에 대한 추상화

객체에 대한 추상화는 다음과 같이 실현됩니다.

* 유사한 객체(즉, 동일한 속성을 가진 객체)를 클래스로 그룹화합니다.
* 우리는 객체, 특히 객체가 지원하는 동작과 관련된 속성을 설정합니다(이를
  위해서는 작업에 대한 추상화를 수행해야 합니다).

객체에 대한 추상화를 매우 진보된 방식으로 지원하는 능력은 모든 객체 지향
프로그래밍 언어(예: Java, C++, C# 등)의 기본 기능입니다. 이러한
언어에서는 프로그래밍 언어 수준에서 _클래스를_ 직접 정의하는 기능을 통해
이러한 추상화 형태가 지원됩니다 .

Java에서 *클래스 정의는* 다음과 같은 특징이 있습니다.

* 클래스 자체를 식별하고 그에 따라 해당 인스턴스의 유형을 식별하는
  클래스 이름 _입니다 ._
* 객체 내부에 데이터를 저장할 수 있는 인스턴스 _변수 ( 데이터
  필드_ 라고도 함 )
* _(인스턴스) 메서드_ ( _작업 필드_ 라고도 함 )는 클래스의 객체에 대해
  호출되어 작업을 수행할 수 있습니다.

_참고:_ 인스턴스 변수와 메소드는 Java 클래스 객체의 속성을 나타냅니다.

또한 적절한 *액세스 수정자를* 통해 다음을 지정할 수 있습니다.

* 클래스 외부, 즉 클래스의 클라이언트에게 표시되어야 하는 필드 - 이러한
  필드를 _public_ 이라고 합니다 .
* 어떤 필드는 클라이언트와 관련이 없기 때문에 클라이언트에게 숨겨야
  합니다. 이러한 필드를 private라고 합니다 .

=== 3.19 모듈로 보는 클래스

모듈로 표시되는 클래스는 다음과 같은 특징이 있습니다(공용 인스턴스
변수는 없다고 가정합니다):

* _내보내진 서비스_ : 공용 메소드, 즉 클래스 외부에서 볼 수 있는 메소드;
* _인터페이스_ : 공개 메소드의 헤더;
* _가져온 서비스_ : 객체 및 클래스 메서드의 표현을 구현하는 데 사용되는
  기타 메서드 또는 클래스입니다.
* _내부 구조_ : 객체의 표현과 클래스의 메소드 구현.

_참고:_ 객체에 대한 추상화는 작업에 대한 추상화를 활용합니다.

=== 3.20 클래스의 정의

구문:

[source,java]
----
public class Name {
  field-1
  ...
  field-n
}
----

* _이름_ 은 클래스 이름입니다.
* _field-1_ … _field-n은_ 해당 속성을 나타내는
  클래스의 _필드_ 입니다 각 _field-i는 데이터 필드_ 또는 _작업 필드_ 일 수
  있습니다.
  ** 데이터 _필드_ (또는 _인스턴스 변수_ )는 변수 선언입니다
  ** 작업 _필드_ (또는 _method_ )는 메서드 정의입니다(나중에 참조)

각 필드는 클래스 외부에서의 가시성을 결정하는 _액세스 한정자_ 로
한정됩니다

의미:

클래스를 정의합니다.

* 데이터 필드(또는 인스턴스 변수)는 클래스 객체의 내부 구조를 나타내는
  데 사용됩니다.
* 작업 필드(또는 메서드)는 클래스의 기능을 구현하는 데 사용됩니다.

=== 3.21 클래서 정의의 예

우리는 사람을 나타내는 Java 클래스를 구현하고 싶습니다. 개인 객체에 대한
관심 속성은 한 번 정의된 _이름_ 과 변경될 수 있는 _거주지 입니다._

사람을 나타내는 Java 클래스 Person을 정의해 보겠습니다 .

[source,java]
----
public class Person {
// instance variables (data fields)
private String name;
private String residence;

    // methods (operation fields)
    public String getName() {
        return name;
    }

    public String getResidence() {
        return residence;
    }

    public void setResidence(String newResidence) {
        residence = newResidence;
    }
}
----

Person 클래스의 정의는 다음 요소로 구성됩니다.

* 클래스 이름, 즉 Person ;
* String 유형의 두 개의 개인 데이터 필드(또는 인스턴스 변수) ,
  즉 name 및 Residence ;
* 3개의 공개 필드. 각 필드는 메소드 정의,
  즉 getName , getResidence 및 setResidence 입니다 .

public 및 private 키워드는 공개 필드와 비공개 필드를 지정합니다(나중에
참조).

* 사람의 이름과 거주지는 Person 클래스에 있는 String 유형의 인스턴스
  변수로 각각 __표시__됩니다 . 이러한 변수는 비공개이므로 클래스 외부에서
  액세스할 수 없습니다.
* 클래스에 정의된 두 가지 메소드인 getName 및 getResidence 는 각각
  개인의 이름과 거주지를 반환
* 대신 setResidence 메소드를 사용 하면 해당 메소드에 대한 호출 객체가
  나타내는 사람의 거주지를 변경할 수 있습니다.

setResidence 와 같은 메소드가 호출된 객체를 수정하는
경우 *부작용이* 있다고 말합니다 (예: StringBuffer 클래스의 메소드
참조 ). 일반적으로 클래스의 메서드에 부작용이 있어야 하는지 여부를
결정하는 것은 클라이언트가 클래스를 사용해야 하는 방식에 중요한 영향을
미치는 디자인 선택입니다.

_참고:_ 클래스 정의는 클래스와 이름이 같고 확장자가 .java 인 파일에
저장되어야 합니다 . 예를 들어, Person 클래스의 정의는 Person.java 라는
파일에 저장되어야 합니다 .

_참고:_ 클래스 정의에서 필드(인스턴스 변수 및 메소드)의 순서는 관련이
없습니다.

=== 3.22 정의된 클래스 사용

프로그래머가 정의한 클래스는 미리 정의된 클래스(예: String )와 정확히
동일한 방식으로 사용됩니다.

[source,java]
----
public class ClientClassPerson {
  public static void main(String[] args) {
    Person p1;
    p1 = new Person();
    p1.setResidence("Roma");
    System.out.println(p1.getResidence());
  }
}
----

ClientClassPerson 클래스는 이러한 클래스를 사용하므로 Person 클래스의
클라이언트입니다 . 클라이언트는 main 메소드 (먼저 호출되는 프로그램의
메소드)를 정의합니다.

[arabic]
. Person 유형 (또는 더 정확하게는 Person 인스턴스인 객체에 대한 참조
유형 ) 의 main 로컬 변수를 정의합니다 .
. Person 클래스의 새 객체를 생성 하고 이에 대한 참조를 p1 에 할당합니다.
. p1 으로 표시된 객체에 대해 Person 클래스의 setResidence 메소드를 호출
하고 실제 매개변 "Roma" 를 메소드에 전달합니다 . 클래스의 (공용)
필드(이 경우 setResidence 메소드 ) 를 선택하기 위해 *선택
연산자* "."를 사용한다는 점에 유의하십시오 .
. 마지막으로 p1 에서 getResidence 메소드를 호출하여 p1 으로 표시된
객체의 거주지를 인쇄합니다.

_참고:_ ClientClassPerson 클래스는 ClientClassPerson.java 라는 파일에
저장되어야 합니다 . ClientClassPerson 클래스를 컴파일하거나 실행하는
동안 문제를 방지하려면 Person 클래스를 포함하는 파일과 동일한 디렉터리에
파일을 배치해야 합니다 . _소위 패키지를_ 사용하여 이러한 제한을 극복할
수 있지만 이 과정에서는 패키지를 다루지 않습니다.

=== 3.23 클래스 필드에 대한 접근 제어

접근 *한정자* public 과 private 의 의미는 다음과 같습니다:

* public은__표시됨을 나타냅니다.__ 메소드/인스턴스 변수가 클래스 외부,
  즉 클래스의 클라이언트에 의해
* private은 메서드/인스턴스 변수가 클래스 외부에 _표시되지 않으므로
  클라이언트가 아닌 클래스 내부에서만 사용할 수 있음을 나타냅니다._

예)

[source,java]
----
public class ClientClassPerson2 {
  public static void main(String[] args) {
    Person p1;
    p1 = new Person();
    p1.setResidence("Roma");
    // OK! the field setResidence is public
    System.out.println(p1.getResidence());
    // OK! the field getResidence is public
    System.out.println(p1.residence);
    // ERROR! the field residence is private
  }
}
----

이 예는 Person 클래스의 공개 및 비공개 필드에 액세스하려고 시도하는
클라이언트를 보여줍니다 . 공용 필드인 setResidence 및 getResidence 에
대한 액세스는 허용되지만 개인 필드인 Residence 에 대한 액세스는 컴파일
시 오류를 발생시킵니다.

=== 3.24 클래스의 필드에 엑세스하기 위한 규칙

일반적으로 클래스 필드에 대한 액세스는 다음과 같이 수행됩니다.

* 클라이언트가 관심을 갖는 클래스 기능에 해당하는 메서드는 public 으로
  선언됩니다 .
* 인스턴스 변수와 보조 메서드, 즉 관심 기능을 나타내는 메서드를 구현하는
  데 도움이 되는 메서드는 private 으로 선언됩니다 .

이런 방식으로 클라이언트가 관심을 갖는 기능에 해당하는 메소드는 클래스
외부에 표시되고, 해당 기능을 지원하는 데 필요하지만 클라이언트가 관심을
갖지 않는 인스턴스 변수 및 보조 메소드는 클래스 내부에서만 볼 수
있습니다.

클래스의 공개 필드 집합을 클래스의 *공개 인터페이스 라고 합니다.*

_참고: Java에는_ protected 와 ``visible in the package’’ 라는 두 가지
추가 액세스 방식이 있습니다 (후자는 액세스 한정자를 생략하여
얻습니다). 이 과정에서는 이러한 내용을 다루지 않지만 후속 프로그래밍
과정에서 다루게 됩니다.

=== 3.25 인스턴스 변수

*인스턴스 변수는* 클래스에 정의되어 있지만 메서드 본문 외부에 정의된
변수입니다. 인스턴스 변수 선언은 메서드의 지역 변수 선언과 유사하지만
다음과 같습니다.

[arabic]
. 변수는 클래스 내부에 정의되지만 모든 메소드 외부에 정의됩니다.
. 변수 앞에는 액세스 한정자(보통 private )가 옵니다.
. 변수는 객체가 생성될 때 암시적으로(기본값으로) 또는 생성자에 의해
명시적으로(나중에 참조) _항상 초기화 됩니다._

_참고:_ 이는 연관된 메모리 위치가 생성될 때 반드시 초기화되지 않는 로컬
변수와 다릅니다.

인스턴스 변수는 전체 클래스가 아닌 단일 개체와 연결됩니다. 즉, 각
개체에는 고유한 인스턴스 변수가 있습니다. 두 개의 서로 다른 객체에는
서로 다른 인스턴스 변수가 있습니다.

image::https://github.com/NHN-academy-Avocado/Avocado/assets/80580473/8ff08958-3f1a-469f-a8db-db0028d3962c[Untitled3]

=== 3.26 인스턴스 변수의 범위

_인스턴스 변수는 클래스의 모든 메서드에 항상 표시됩니다._ 그들은 항상
호출 객체를 참조합니다.

_예:_ 명령문에서 return name; 인스턴스 변수 이름은 메서드에 대한 호출
개체의 인스턴스 변수입니다.

공용 인스턴스 변수는 클래스 외부에서 볼 수 있으며 필드 선택 연산자
``.''를 사용하여 해당 변수가 속한 객체에 대한 참조를 통해 액세스할 수
있습니다.

_예:_ 사람을 나타내기 위해 클래스를 다음과 같이 정의했다면:

[source,java]
----
public class Person2 {
// instance variables (data fields)
private String name;
public String residence; // residence is declared public
// methods (operation fields)

    public String getName() {
        return name;
    }

    public String getResidence() {
        return residence;
    }

    public void setResidence(String newResidence) {
        residence = newResidence;
    }
}
----

그런 다음 다음 클라이언트에서 볼 수 있듯이 인스턴스 변수 Residence 에
직접 액세스할 수 있습니다.

[source,java]
----
public class ClientClassPerson2 {
  public static void main(String[] args) {
      Person2 p1;
      p1 = new Person2();
      p1.setResidence("Roma");
      // OK! the field setResidence is public
      System.out.println(p1.getResidence());
      // OK! the field getResidence is public
      System.out.println(p1.residence);
      // OK! the field residence is public
  }
}
----

_참고:_ 일반적으로 클래스 개체의 표현을 클라이언트로부터
숨기려면 인스턴스 변수를 private 으로 선언해야 합니다. 따라서
클라이언트를 수정할 필요 없이 그러한 표현을 자유롭게 변경할 수 있습니다

=== 3.27 인스턴스 변수의 수명

_인스턴스 변수의 수명은 해당 변수가 속한 개체의 수명과 정확하게
일치합니다._ 인스턴스 변수는 이를 포함하는 객체가 생성되는 순간 생성되며
객체에 액세스할 수 있는 한 사용할 수 있습니다. 변수로 표시되는 객체의
생성은 런타임 지원(Java Virtual Machine)에 의해 객체와 함께 인스턴스
변수의 값을 저장하는 데 필요한 메모리를 할당하여 수행됩니다.

_가비지 수집_ 메커니즘을 통해 런타임 지원은 개체에 대한 참조가 더 이상
없을 때 개체를 자동으로 삭제하고 개체가 차지하는 메모리를 해제하므로
개체에 더 이상 액세스할 수 없습니다.

=== 3.28 메소드의 정의

*메소드의 정의는* 앞서 살펴본 정적 메소드의 정의와 유사하지만, 메소드
헤더에 static 키워드가 나타나지 않습니다. 이는 메서드에 호출 객체가
필요함을 나타냅니다.

따라서 메소드의 정의는 다음과 같이 구성됩니다.

헤더 블럭

* _header_ 는 메소드의 헤더이며 다음과 같은 형식을 갖습니다.

[source,java]
----
public resultTyp methodName(formatParameters)
----

여기서 (정적 메소드의 경우)

* public은 정의된 메서드가 클래스 외부에서 액세스 가능함을 나타냅니다.
* _resultType_ 은 메소드가 반환한 결과의 유형이거나,메소드가 어떤 결과도
  반환하지 않는 경우에는void입니다 .
* _methodName은_ 메소드의 이름입니다.
* _형식 매개변수는_ 쉼표로 구분된 매개변수 선언(유형 및 이름)
  목록입니다. 각 매개변수는 변수입니다. 매개변수 목록이 비어 있을 수도
  있습니다.
* _block_ 은 메소드가 호출될 때 실행될 명령문을 포함하는 메소드의
  본문입니다. 정적 메소드의 경우 다음과 같은 형식을 갖습니다

[source,java]
----
{
statements
}
----

=== 3.29 암시적 형식 매개변수 this

모든 인스턴스(즉, 비정적) 메서드에는 this 로 표시되는 암시적 형식
매개변수가 있습니다 . 이러한 매개변수는 호출 객체를 나타냅니다. 즉,
메소드가 호출되면 이는 호출 객체(참조)에 바인딩되어 실제 매개변수로
작동합니다.

this 매개변수는 인스턴스 변수와 호출 객체의 메서드에 액세스하는 데
사용됩니다. 일반적으로 지금까지 했던 것처럼 이것을 생략할 수 있습니다
. 실제로 Java는 인스턴스 변수나 클래스의 인스턴스 메서드를 사용할 때마다
자동으로 삽입합니다.

_예: 아래에 제공된_ Person 클래스의 정의는 우리가 이미
본 Person 클래스와 정확히 동일한 의미를 갖습니다

[source,java]
----
public class Person {
// instance variables (data fields)
private String name;
private String residence;

    // methods (operation fields)
    public String getName() {
        return this.name;
    }

    public String getResidence() {
        return this.residence;
    }

    public void setResidence(String newResidence) {
        this.residence = newResidence;
    }
}
----

_참고: 형식 매개변수_ this 에 값을 할당할 수 없습니다 . 가능하다면 이는
실제로 메소드의 호출 객체를 변경한다는 의미입니다.

=== 3.30 this의 사용

일반적으로 메소드 내부에 인스턴스 변수와 동일한 이름으로 선언된 지역
변수(또는 형식 매개변수)가 있고, 인스턴스 변수와 지역 변수를 구별하고
싶을 때 사용됩니다 . 실제로 인스턴스 변수와 동일한 식별자를 사용하여
지역 변수를 선언하면 지역 변수의 이름이 인스턴스 변수의 이름을 숨기고
이를 명시적으로 사용하여 인스턴스 변수를 표시해야 합니다(암시적 사용)

예)

[source,java]
----
public class Person {
private String name;
private String residence;

    public String getName() {
        return name;
    }

    public String getResidence() {
        String residence;
        // the local variable masks the instance variable with the same name
        residence = this.residence;
        // this is used to distinguish the instance var from the local var
        return residence;
        // here we are referring to the local variable
    }

    public void setResidence(String residence) {
        this.residence = residence;
        // this is again used to distinguish the instance var from the local var
    }
}
----

=== 3.31 생성자

지금까지 살펴본 내용으로는 Person 개체 의 필드 이름을 적절한 값으로
초기화할 수 있는 방법이 없습니다 . 예를 들어 John Smith와 같이 객체를
대응시키는 방법을 모릅니다. 인스턴스 변수 이름에는 ``John Smith'' 값이
있어야 하지만 이 변수는 private 이므로 다음 명령문은 잘못되었습니다.

[source,java]
----
Person p = new Person();
p.name = "John Smith"; // ERROR! name is declared private
----

객체의 개인 인스턴스 변수를 명시적으로 초기화할 수 있게 하려면 생성자를
사용해야 합니다. 생성자 *는* 클래스와 이름이 같고 명시적인 반환 값( void
도 *아님 )이 없는 클래스의 (정적이 아닌)* 단순한 메서드 입니다 .

예를 들어 생성할 사람 의 이름과 거주지를 인수로 사용하는 Person 클래스의
생성자를 구현해 보겠습니다 .

[source,java]
----
public class Person {
...
  // constructor name-residence
  public Person(String n, String r) {
    name = n;
    residence = r;
  }
...
}
----

=== 3.32 생성자 호출

생성자는 new 연산자 를 사용하여 객체가 생성될 때 런타임 지원(Java
Virtual Machine)에 의해 자동으로 호출됩니다 . 예를 들어, 다음 코드
조각을 사용하면

[source,java]
----
Person p = new Person("John Smith", "London");
// constructor name-residence is called
System.out.println(p.getResidence());
// prints "London"
----

런타임 지원은 Person 클래스 의 객체를 생성(즉, 메모리를 할당) 하고 매개
변수로 전달된 값에 대해 필드 이름 과 거주지를 명시적으로 초기화하는
생성자 Person(String,String) 을 호출합니다. 그러면 새로 생성된 객체에
대한 참조가 변수 p 에 할당됩니다 .

다음 코드 조각을 고려해보세요.

[source,java]
----
사람 p; // (1)
p = new Person("John Smith", "런던"); // (2)
----

(1)에서는 Person 유형의 개체에 대한 참조 유형의 변수 p를 정의하고 ,
(2)에서는 새 개체 Person을 만들고 이에 대한 참조를 변수 p 에 할당합니다
.

_참고:_ new 연산자는 생성자를 사용하여 객체를 생성하고 해당 객체에 대한
참조를 반환합니다 . 이러한 참조는 다음을 수행할 수 있습니다.

* Person 에 대한 형식 참조 형식 매개변수가 있는 메서드에 실제 매개변수로
  전달됩니다 .
* 반환 값이 Person 에 대한 참조 유형인 메서드의 결과로 반환됩니다 .

_참고:_ 모든 생성자를 클래스의 공개 필드로 선언하는 것이
중요합니다. 비공개로 선언된 경우 클래스의 개체를 만들려고 하면 오류가
발생합니다.

=== 3.33 생성자 오버로딩

Java는 메소드의 오버로드를 허용하고 생성자는 메소드의 특수한 경우이므로
클래스에 대해 여러 생성자를 정의하는 것이 가능합니다.

예를 들어, 생성되는 사람의 거주지를 null 로 설정하는 생성자를 정의할 수
있습니다 .

[source,java]
----
// constructor name
public Person(String n) {
  name = n;
  residence = null;
}
----

생성자를 사용하는 방법에 대한 몇 가지 예를 보여줍니다.

[source,java]
----
Person p1 = new Person("John Smith");
// calling constructor name
Person p2 = new Person("Tom Jones", "London");
// calling constructor name-residence
System.out.println(p1.getName());
// prints "John Smith"
System.out.println(p2.getName());
// prints "Tom Jones"
----

새 작업 을 통해 객체를 생성할 때 컴파일러는 새 작업에 지정된 매개변수의
수와 유형을 기반으로 사용할 생성자를 결정합니다. 그러면 런타임 지원에서
선택한 생성자를 호출하여 개체를 만들 수 있습니다.

=== 3.34 표준 생성자

생성자 정의가 포함되지 않은 클래스(예: Person 클래스 의 첫 번째 버전 )의
객체를 생성하면 소위 *표준 생성자가* 호출됩니다.

* 표준 생성자는 생성자 정의가 포함되지 않은 모든 클래스에 대해
  컴파일러가 자동으로 생성한 _인수가 없는 생성자 입니다._
* _초기화된 인스턴스 변수는 기본값_ 으로 유지됩니다 . 기본값은 변수와
  관련된 메모리 위치가 예약될 때 런타임 지원에 의해 자동으로 할당되는
  값입니다.
* 표준 생성자는 생성자의 정의(인수 포함 여부와 관계 없음)가 클래스에
  명시적으로 있는 경우 컴파일러에 의해 자동으로 금지됩니다. 특히
  프로그래머는 표준 생성자를 대체하는 인수 없이 생성자를 명시적으로 정의할
  수도 있습니다.

예를 들어 Person 클래스의 경우 인수 없이 다음 생성자를 정의할 수
있습니다.

[source,java]
----
public Person() { // constructor without arguments
  name = "John Smith";
  residence = null;
}
----

_참고:_ 클래스에 대해 인수 없이 생성자를 정의하는 것이 항상 의미가 있는
것은 아닙니다. 예를 들어, Person 클래스에 대한 인수가 없는 생성자의
정의는 확실히 의문의 여지가 있습니다.

=== 3.35 클래스를 위한 디자인 방법론: 클래스의 구현

우리는 문제를 다양한 하위 문제로 나누고 각각을 개별적으로 해결함으로써
구조화된 방식으로 Java 클래스를 실현할 수 있도록 다양한 단계로 클래스를
설계하는 방법론을 제시합니다. 이러한 방식으로 우리는 간단하고 효과적인
방법으로 클래스 구현의 복잡성을 처리할 수 있습니다.

[arabic]
. 클래스 명세부터 시작하여, _구현하고자 하는 클래스의 속성과 서비스를
식별합니다_ .
. 필요한 인스턴스 변수를 식별하여 _클래스 객체에 대한 표현을_ 선택합니다
.
. _클래스의 public 메소드_ (클래스의 인터페이스) 헤더를 선택합니다 . 이
단계에서는 클래스의 클라이언트가 우리가 구현하고 있는 클래스의 개체를
사용해야 하는 방식을 결정합니다.
. 우리는 코드를 단순화하고 구조화하기 위해 보조 메소드를
도입함으로써 public _메소드의 본문을 실현합니다 ._

=== 3.36 클래스를 위한 디자인 방법론: 클래스의 클라이언트

클래스가 구현되면 클래스의 예제 클라이언트도 구현하여 클래스가 실제로
어떻게 사용되는지 확인해야 합니다. 그렇게 하기 위해 클래스의 공개
메소드의 본문을 알 필요는 없습니다. 실제로 클라이언트의 관점에서 볼 때
중요한 것은 *클래스* 의 공개 메서드가 수행하는 방식 *이 아니라
무엇을* 수행하는가입니다.

이는 공개 메소드의 본문을 구현하기 전에(따라서 보조 메소드를 도입하기
전에) 클래스 클라이언트의 구현을 예상할 수도 있음을 의미합니다.

실제로 3단계 이후에 우리는 소위 *클래스의 골격* , 즉 클래스 자체를
실현할 수 있습니다. 여기에는 정의 대신 공용 메서드의 헤더만 있고 전용
메서드는 없습니다.

클래스의 골격은 클래스의 클라이언트를 구현하기에 충분합니다.

=== 3.37 클래스 디자인의 예

_사양:_ 자동차를 표현하기 위한 Java 클래스를 구현합니다. 자동차의 관심
속성은 번호판, 모델, 색상, 자동차 소유자입니다. 처음 두 속성은 수정할 수
없지만 세 번째와 네 번째 속성은 수정할 수 있습니다. 자동차에는 원래
주인이 없습니다. 소유자는 나중에(예: 자동차가 판매된 경우) 자동차에
할당됩니다.

위 사양을 분석하면 기능이 다음과 같은 Car 클래스를 구현해야 한다는 것을
알 수 있습니다 .

* 적절한 값으로 초기화된 속성 플레이트, 모델 및 색상을 사용하고 소유자는
  없는 클래스의 객체를 생성합니다.
* plate, model, color, owner 각각의 속성 값을 반환하는 단계;
* 색상이나 소유자를 변경합니다.

이제 다음과 같이 작성할 준비가 되었습니다.

[source,java]
----
public class Car {
// private representation of the objects: instance variables
// public methods realizing the requested functionalities
}
----

=== 3.38 클래스 디자인의 예: 객체 표현

우리는 자동차의 속성을 어떻게 표현할 것인지 결정해야 합니다. 이 경우
표현을 선택하는 것이 즉각적입니다. 다음 인스턴스 변수를
사용하여 Car 클래스의 객체를 나타냅니다 .

* String 유형의 인스턴스 변수 plate를 사용하는 plate
* String 유형의 인스턴스 변수 model을 사용하는 model
* String 유형의 인스턴스 변수 color를 사용하는 color
* Person 유형의 person 인스턴스 변수를 사용하는 person

_참고:_ 초기 예에서는 표현 선택이 항상 즉각적으로 이루어집니다. 그러나
과정을 진행하면서 이 단계가 훨씬 더 복잡해질 수 있음을 알게 될 것입니다.

이제 다음과 같이 작성할 준비가 되었습니다.

[source,java]
----
public class Car {
  // representation of the objects
  private String plate;
  private String model;
  private String color;
  private Person owner;
  // public methods realizing the requested functionalities
}
----

=== 3.39 클래스 디자인의 예: public interface

이제 클라이언트가 객체를 사용할 수 있는 Car 클래스의 인터페이스를 선택할
준비가 되었습니다 . 특히, 각 기능에 대해 이를 실현하는 public 메소드를
정의하고 헤더를 결정해야 합니다.

요청된 기능은 다음과 같습니다:

클래스의 객체를 생성하고, "plate" (차량 번호판), "model" (모델),
``color'' (색상) 등의 속성을 적절히 초기화하며, 소유자(owner) 없이
객체를 생성하는 것을 의미합니다.

클래스의 객체를 생성하기 위해서는 생성자를 사용해야 한다는 것을 알고
있습니다. 따라서 이 기능을 사용하려면 생성자를 정의해야 합니다. 특히, 이
생성자는 차량 번호판(plate), 모델(model), 그리고 색상(color)을 나타내는
인스턴스 변수를 적절한 매개변수를 사용하여 초기화해야 합니다(참고로,
처음 두 속성은 더 이상 변경할 수 없습니다). 그러나 owner라는 인스턴스
변수는 의미 없는 값인 null로 초기화되어야 합니다.

이 생성자의 헤더(header)는 다음과 같습니다:

[source,java]
----
public Car(String p, String m, String c)
----

각각의 속성인 "plate" (차량 번호판), "model" (모델), "color"
(색상), 그리고 ``owner'' (소유자)의 값을 반환하는 메서드를 작성한다면,
이를 영어로 나타내면 다음과 같습니다:

네 가지 속성 각각에 대해 값(정확히 말하면 값을 나타내는 개체에 대한
참조)을 반환하는 공개 메서드를 정의합니다. 이러한 메소드의 헤더는 다음과
같습니다.

[source,java]
----
public String getPlate()
public String getModel()
public String getColor()
public Person getOwner()
----

_색상 및 소유자 속성 값을 수정합니다._

색상과 소유자를 수정하기 위해 헤더가 다음과 같은 두 가지 메서드를
도입합니다.

[source,java]
----
public void setColor(String newColor)
public void setOwner(Person newOwner)
----

이 시점에서 Car 클래스의 뼈대를 작성할 수 있습니다 .

[source,java]
----
public class Car {
// representation of the objects
private String plate;
private String model;
private String color;
private Person owner;

    // constructor
public Car(String p, String m, String c) {
...
}

    // other pubblic methods
public String getPlate() {
...
}

public String getModel() {
...
}

public String getColor() {
...
}

public Person getOwner() {
...
}

public void setColor(String newColor) {
...
}

public void setOwner(Person newOwner) {
...
}
}
----

참조__:__ 생성자를 도입했기 때문에 더 이상 표준 생성자를 사용할 수
없습니다. 반면에 우리는 인수 없이 생성자를 정의하는 데 관심이 없습니다.
왜냐하면 Car 객체 가 생성되는 순간 플레이트와 객체 모델을 한 번에
수정해야 하기 때문입니다.

=== 3.40 클래스의 설계의 예: 메소드 구현

이제 우리는 다양한 방법에 집중하고 그 몸을 구현합니다.

생성자부터 시작합니다.

[source,java]
----
public Car(String p, String m, String c) {
  plate = p;
  model = m;
  color = c;
  owner = null;
}
----

_참고:_ owner = null 문을 생략하면 ; 어쨌든 소유자 는 객체 참조의
기본값인 null 로 자동으로 초기화됩니다 . _어쨌든 모든 인스턴스 변수를
명시적으로 초기화하여_ 자동 초기화를 사용하지 않는 것이 좋은 프로그래밍
관행입니다 .

우리는 비슷한 방식으로 다른 방법을 실현합니다.

[source,java]
----
public class Car {
// representation of the objects
private String plate;
private String model;
private String color;
private Person owner;

    // constructor
    public Car(String p, String m, String c) {
        plate = p;
        model = m;
        color = c;
        owner = null;
    }

    // other public methods
    public String getPlate() {
        return plate;
    }

    public String getModel() {
        return model;
    }

    public String getColor() {
        return color;
    }

    public Person getOwner() {
        return owner;
    }

    public void setColor(String newColor) {
        color = newColor;
    }

    public void setOwner(Person newOwner) {
        owner = newOwner;
    }
}
----

=== 3.41 클래스 디자인의 예: 클라이언트

Car 클래스의 CarServices 클라이언트를 구현해
보겠습니다 . CarServices 클래스에는 두 가지 정적 메서드가 포함되어
있습니다.

* spray 메소드는 Car 객체(에 대한 참조) 와 자동차의 (새) 색상을
  나타내는 String 객체(에 대한 참조)를 매개변수로 취하고 색상을
  변경하여 Car 객체를 수정합니다
* RegisterAlfa147 메소드는 번호판과 색상을 각각 나타내는 두
  개체 문자열을 매개 변수로 사용 하고 모델이 ``Alfa147'' 이고 번호판과
  색상이 매개 변수에 의해 지정되는 새 개체 Car를 반환합니다(참조).

다음과 같이 CarServices.java 라는 파일에 CarServices 클래스를
작성합니다 .

[source,java]
----
public class CarServices {
public static void spray(Car car, String color) {
car.setColor(color);
}

    public static Car registerAlfa147(String pla, String col) {
        return new Car(pla, "Alfa147", col);
    }
}
----

마지막으로 Car 클래스 와 CarServices 클래스를 사용하는 main 메서드를
포함하는 Main 클래스를 구현합니다 . 이 클래스는 별도의 파일 Main.java 에
작성됩니다 .

[source,java]
----
public class Main {
// auxiliary method
    private static void printCarData(Car a) {
      System.out.println("Car: " + a.getPlate() + ", " + a.getModel() + ", " + a.getColor());
    }

    // auxiliary method
    private static void printOwnerData(Car a) {
        System.out.println("Owner: " + a.getOwner().getName() + ", " + a.getOwner().getResidence());
    }

    public static void main(String[] args) {
        Car a = new Car("313", "Fiat 500", "Red and Blu");
        printCarData(a);
        Person p = new Person("Paperino", "Paperopoli");
        a.setOwner(p);
        printOwnerData(a);
        CarServices.spray(a, "Maranello Red");
        printCarData(a);
        Car b = CarServices.registerAlfa147("131", "Alfa Red");
        printCarData(b);
        Person c = new Person("Clarabella", "Topolinia");
        b.setOwner(c);
        printOwnerData(b);
    }
}
----

=== 3.42 상속

*객체 지향 언어의 상속은 기존 클래스를* _특수화한_ 클래스를 정의할 수
있는 가능성으로 구성됩니다 . 즉, 이미 존재하는 클래스와 동일한 속성을
가지지만 새 기능or 새로운 정보를 추가하려는 클래스를 정의하는 것입니다.

이미 정의된 클래스를 수정하는 대신 해당 클래스에서 _파생된_ 새 클래스를
만듭니다 . 예를 들어:

[source,java]
----
public class Student extends Person {
...
}
----

우리는 이렇게 말합니다:

* Student 는 Person 의 _하위 클래스_ 입니다 . Person
  은 Student 의 _슈퍼클래스_ 입니다 .
* Student 는 _기본 클래스인_ Person 에서 _파생된 클래스_ 입니다 .

하위 클래스는 상위 클래스의 모든 메서드와 인스턴스 변수를 _상속하며 ,
추가로 자체 메서드와 인스턴스 변수를 가질 수도 있습니다._

=== 3.43 상속: 예

다음과 같이 Person 클래스에서 Student 서브클래스를 파생합니다 .

[source,java]
----
public class Student extends Person {
private String faculty;

public Student(...) { // constructor
...
}

    public String getFaculty() {
        return faculty;
    }
}
----

Student 클래스의
개체는 Person 클래스에서 _상속된_ 속성 과 _추가로_ 학생이 등록된
교수진에 의해 특징 지어집니다.

=== 3.44 파생 클래스의 기본 기능

* 기본 클래스에 대해 정의된 모든 속성(인스턴스 변수 및 메서드)은 파생
  클래스에 대해서도 암시적으로 정의됩니다. 즉, 파생 클래스에 의해
  상속됩니다.
* 파생 클래스는 기본 클래스에서 상속된 속성과 관련하여 추가 속성을 가질
  수 있습니다.
* 파생 클래스의 각 인스턴스는 기본 클래스의 인스턴스이기도
  합니다. 따라서 기본 클래스의 개체를 사용할 수 있는 모든 상황에서는 파생
  클래스의 개체를 사용할 수 있습니다.
* 그 반대는 사실이 아니라는 점에 유의하십시오. 즉, 파생 클래스의 객체를
  사용하는 것이 가능한 각 상황에서는 기본 클래스의 객체를 사용하는 것이
  불가능합니다(나중에 참조) _._

=== 3.45 파생 클래스의 생성자

이제 클래스 간 파생이 있는 경우 생성자를 정의하는 방법을 분석해
보겠습니다. 파생 클래스의 생성자는 기본 클래스의 필드 구성도 처리해야
합니다. 이는 특수 Java 구문 super() 를 사용하여 파생 클래스의 생성자에
기본 클래스의 생성자에 대한 호출을 삽입하여 수행할 수
있습니다 . super () 문은 파생 클래스 생성자의 본문에서 _첫 번째 실행
가능 문_ 으로 나타나야 합니다 . 예를 들어:

[source,java]
----
public class Student extends Person {
  public Student(String n, String r, String f) {
    super(n,r); // calls the constructor Person(String,String)
    faculty = f;
  }
...
}
----

person(n r)을 호출하는 super(n, r)을 호출합니다.

이는 슈퍼클래스 Person 에서 각각 상속된 인스턴스
변수 name 및 Residence를 문자열 n및 r 로 초기화합니다

그러면 faculty = f; 인스턴스 변수 faculty에 문자열 f 를 할당합니다 .

=== 3.46 super의 사용

일반적으로 하위 클래스에 자체 인스턴스 변수가 있는 경우 해당 생성자는
먼저 슈퍼클래스의 객체를 생성한 다음( super 사용 ) 자체 인스턴스 변수를
생성해야 합니다.

* super() 를 삽입하는 것을 잊어버리면 어떻게 되나요 ? 그런 다음
  슈퍼클래스의 인자가 없는 생성자가 자동으로 호출됩니다(분명히 인수가 없는
  생성자가 슈퍼클래스에 대해 정의되지 않은 경우 컴파일 오류가 발생합니다).
* 하위 클래스에 대한 생성자를 정의하는 것을 잊어버리면 어떻게
  되나요? 그런 다음 인수가 없는 생성자가 자동으로 정의됩니다. 이러한
  생성자는 슈퍼클래스의 인수 없이 생성자를 호출하고 하위 클래스의
  적절한(상속되지 않은) 인스턴스 변수를 기본값으로 초기화합니다.
* 이 과정에서는 이러한 자동 정의를 절대 사용하지 않습니다. 대신, 우리는
  항상 첫 번째 문에서 super() 를 호출하는 방식으로 하위 클래스의 생성자를
  명시적으로 정의합니다 .

=== 3.47 상속된 메서드 및 변수

우리가 말한 것에서 Student 클래스의 모든 객체는 Student 에 정의 된
적절한 메서드와 인스턴스 변수를 갖는 것 외에도 Person 의 모든 메서드와
인스턴스 변수를 _상속합니다_ . 예를 들어 다음과 같이 작성할 수 있습니다.

[source,java]
----
public class TestStudent {
  public static void main(String[] args) {
    Person p = new Person("Daniele", "Roma");
    System.out.println(p.getName());
    System.out.println(p.getResidence());
    Student s = new Student("Jacopo", "Roma", "Engineering");
    System.out.println(s.getName()); // OK! method inherited from Person
    System.out.println(s.getResidence()); // OK! method inherited from Person
    System.out.println(s.getFaculty()); // OK! method defined in Student
  }
}
----

Person 에서 상속된 getName() 및 getResidence() 메서드 는
사실상 Student 클래스의 메서드입니다 .

=== 3.48 호환성

우리는 파생 클래스의 각 객체가 기본 클래스의 객체이기도 하다고
말했습니다. 이는 기본 클래스의 객체를 사용할 수 있는 각 상황이나
문맥에서 파생 클래스의 개체를 사용할 수 있음을 의미합니다. 즉, _파생
클래스의 개체는 기본 클래스의 개체와 *호환*_ 됩니다 .

그러나 그 반대는 사실이 아닙니다! 다음 프로그램을 고려해보세요.

[source,java]
----
public class TestCompatibility {
  public static void main(String[] args) {
    Person p = new Person("Daniele", "Roma");
    Student s = new Student("Jacopo", "Roma", "Engineering");
    Person pp;
    Student ss;
    pp = s; // OK! Student is compatible with Person
    ss = p; // ERROR! Person is not compatible with Student
    System.out.println(pp.getName());
    // OK! getName() is a method of Person
    System.out.println(pp.getResidence());
    // OK! getResidenza is a method of Person
    System.out.println(pp.getFaculty());
    // ERROR! getFaculty is not a method of Person
  }
}
----

_참고:_ 마지막 문의 오류는 pp 변수가 Person 에 대한 참조 이므로 이
변수를 통해 Student 의 메서드에 액세스할 수 없기 때문에 발생합니다 (이
경우 pp가 실제로 Person을 참조 하더라도). 개체 학생 ). 이는 Java가 _정적
유형 검사를_ 구현하기 때문입니다 .

=== 3.49 실제 매개변수와 형식 배개변수 간의 호환성

슈퍼클래스와 서브클래스 간의 호환성과 관련해 우리가 본 내용은 매개변수
전달에도 적용됩니다.

[source,java]
----
public class TestCompatibility2 {
    public static void printPerson(Person p) {
      System.out.println(p.getName());
      System.out.println(p.getResidence());
    }

    public static void printStudent(Student s) {
        System.out.println(s.getName());
        System.out.println(s.getResidence());
        System.out.println(s.getFaculty());
    }

    public static void main(String args[]) {
        Person pr = new Person("Daniele", "Roma");
        Student st = new Student("Jacopo", "Roma", "Engineering");
        printPerson(pr); // OK
        printPerson(st); // OK! Student is compatible with Person
        printStudent(st); // OK
        printStudent(pr); // ERROR! Person is not compatible with Student
    }
}
----

=== 3.50 슈퍼클래스의 public&private 필드에 대한 접근

우리가 본 것처럼 파생 클래스는 슈퍼클래스의 모든 인스턴스 변수와 모든
메서드를 상속합니다.

분명히 슈퍼클래스의 공개 필드는 파생 클래스에서 액세스할 수
있습니다. 예를 들어, 다음과 같이 Student 하위
클래스에 printName() 메서드를 추가할 수 있습니다.

[source,java]
----
public class Student extends Person {
  ...
  public void printName() {
     System.out.println(this.getName());
  }
  ...
}
----

슈퍼클래스의 비공개 필드는 어떻습니까? 보다 정확하게는 파생 클래스에
정의된 메서드가 슈퍼클래스의 다른 클라이언트로 간주됩니까, 아니면
슈퍼클래스의 비공개 필드에 액세스할 수 있는 특별한 권한이
있습니까? 대답은 슈퍼클래스 외부의 다른 메소드에서 액세스 _*할 수
없는* 것과 마찬가지로 슈퍼클래스의 비공개 필드도 파생 클래스의
메소드에서 액세스할 수 없다는 것입니다._

예를 들어 Student 에 다음과 같이 ChangeName() 메서드를 도입하면 컴파일
오류가 발생합니다.

[source,java]
----
public class Student extends Person {
...
  public void changeName(String s) {
    this.name = s; //ERROR! the instance variable name is private in Person
    //hence, it is not accessible from the derived class Student
  }
...
}
----

_참고: Java를 사용하면 공개 및 비공개 필드 외에도_ protected 라고 하는
다른 유형의 필드도 사용할 수 있습니다 . 클래스의 보호된 필드는 외부
메서드로 액세스할 수 없지만 파생 클래스의 메서드로는 액세스할 수
있습니다. 이 과정에서는 보호된 필드를 사용하지 않습니다.

=== 3.51 메서드의 오버라이딩

* 우리는 슈퍼클래스의 메소드 m() 과 _정확히 동일한 시그니처를_ 갖는
  메소드 m()을 서브클래스에 정의할 때 메소드 m()의 *오버라이딩을
  수행한다고 말합니다.*
* 재정의를 수행할 때 Java에서는 새 메서드 m() 의 정의에 원래
  메서드 m() 과 동일한 반환 유형이 있어야 합니다 . 즉, 우리가 재정의하는
  메소드는 원래 메소드와 _동일한 헤더를 가져야 합니다._
* 재정의의 결과는 파생 클래스 D 의 객체에 대해 m() 메서드를 호출할
  때마다 효과적으로 호출되는 메서드는 기본 클래스 B 에 정의된 메서드가
  아니라 D 에서 재정의된 메서드라는 것입니다 . 호출 객체를 나타내는 데
  사용된 참조가 B 유형인 경우 . _이 동작을 다형성_ 이라고 합니다 .
* 재정의는 _오버 로드_ (이름은 같지만 시그니처가 다른 두 메서드의
  정의) 와는 다릅니다 .

=== 3.52 메서드의 오버라이딩: 예

Person 에서 다음과 같이 printData 메소드를 정의한다고 가정합니다.

[source,java]
----
public class Person {
...
  public void printData() {
    System.out.println(name + " " + residence);
  }
...
}
----

printData가 교수진도
인쇄하는 방식으로 Student 클래스의 printData 메소드를 재정의합니다

[source,java]
----
public class Student extends Person {
...
  public void printData() { // overriding of printData of Person!!!
    System.out.println(this.getName() + " " + this.getResidence() + " "
    faculty);
  }
...
}
----

클라이언트의 예는 다음과 같습니다.

[source,java]
----
public class ClientStudent {
  public static void main(String[] args) {
    Person p = new Person("Daniele", "Roma");
    Student s = new Student("Jacopo", "Roma", "Engineering");
    p.printData();
    s.printData();
  }
}
----

=== 3.53 다형성

메서드를 재정의하면 *다형성이* 발생합니다 . 이는 동일한 시그니처를
사용하여 다르게 동작하는 메서드가 클래스 계층 구조에 존재함을 의미합니다

다음 프로그램을 고려해보세요.

[source,java]
----
public class StudentPolymorphism {
  public static void main(String[] args) {
    Person p = new Person("Daniele", "Roma");
    Student s = new Student("Jacopo", "Roma", "Engineering");
    Person ps = s; // OK! due to the compatibility rules
    p.printData();
    s.printData();
    ps.printData(); // ??? what does this print ???
  }
}
----

효과적으로 호출되는 printData 메소드는 객체를 나타내는 변수의 유형이
아닌 객체가 속한 클래스를 기반으로 선택됩니다. _메소드에 액세스하기 위한
이러한 메커니즘을 동적 바인딩_ 이라고 합니다 .

위의 예에서 ps 객체에 호출된 메소드는 Student 클래스에 정의된 메소드, 즉
이름, 거주지 및 교수진을 인쇄하는 메소드가 됩니다 . 실제로 프로그램을
실행하면 다음과 같이 인쇄됩니다.

[source,java]
----
Daniele Roma
Jacopo Roma Engineering
Jacopo Roma Engineering
----

=== 3.54 클래스 계층 구조

* 클래스에는 여러 하위 클래스가 있을 수 있습니다. 예를 들어, Person 의
  하위 클래스 ExpertPerson을 정의 할 수 있습니다. 해당 객체는 특정 주제의
  전문가인 사람을 나타내며, 전문가인 주제는 클래스의 특정 속성입니다.
* 클래스의 하위 클래스는 자체적으로 하위 클래스를 가질 수 있습니다. 예를
  들어 Person 에서 파생된 Student 클래스는 WorkingStudent 하위 클래스를
  가질 수 있습니다
* 따라서 여러 파생을 사용하여 클래스 계층을 만드는 것이 가능합니다.

=== 3.55 클래스 객체

Java에서 정의된 모든 클래스는 명시적으로 표시되지 않더라도 미리 정의된
클래스 Object 의 하위 클래스입니다.

이는 모든 클래스가 Object 로부터 equals , clone 및 toString 과 같은 여러
표준 메소드를 상속한다는 것을 의미합니다 . 이 과정에서는 다음 헤더가
있는 toString 메소드 만 고려합니다 .

[source,java]
----
public String toString()
----

이 메소드는 String 의 객체를 변환하는 데 사용됩니다 . 일반적으로 인쇄할
수 있는 개체에 대한 정보가 포함된 문자열을 구성하는 데 사용됩니다. 이를
재정의(즉, 재정의)하지 않으면 Object 클래스의 toString 메소드 (객체에
대한 시스템 코드를 인쇄함) 또는 이를 재정의하는 계층 구조의 가장 가까운
슈퍼클래스에 있는 toString 메소드가 사용됩니다.

예)

[source,java]
----
public class TestToString {
  public static void main(String[] args) {
    Person p = new Person("Pippo", "Topolinia");
    System.out.println(p.toString());
  }
}
----

이 프로그램은 오류 없이 실행되며 화면에 문자열을 인쇄합니다. 예를
들어 ``Person@601bb1'' 은 Object 의 toString 메서드에 의해 정의된 코드에
해당합니다 .

Person 클래스의 toString 메소드를 사람의 이름을 반환하도록 재정의할 수
있습니다.

[source,java]
----
public class Person {
...
  public String toString() {
    return name;
  }
...
}
----

이제 동일한 프로그램 TestToString이 ``Pippo'' 를 인쇄합니다 .

=== 3.56 print와 println에서 toString 사용

미리 정의된 PrintStream 클래스에는 String 대신 Object 에 대한 유형
참조의 형식 매개 변수를 갖는 지금까지 사용했던 print 및 println 메서드의
변형이 포함되어 있습니다 . 이 두 메소드는 Object 유형의 매개변수에
대해 toString 메소드를 호출한 다음 String 에 대해 이미 본 인쇄 메소드를
사용하여 결과 문자열을 인쇄합니다 . 실제로 이를
통해 print 및 println 인수에서 toString 을 명시적으로 사용하는 것을 피할
수 있습니다 .

예)

[source,java]
----
public class TestToString2 {
  public static void main(String[] args) {
    Person p = new Person("Pippo", "Topolinia");
    System.out.println(p);
    // this is equivalent to System.out.println(p.toString());
  }
}
----

_참고: 동적 바인딩_ 메커니즘으로 인해 print 및 println 메소드는 이러한
방식으로 사용될 때 올바르게 작동합니다 .

=== 3.57 합성

Student 와 유사한 기능을 가지고 있지만 상속을 사용하지
않는 클래스 Student2를 정의해 보겠습니다. 아이디어는 Person 객체에 대한
참조인 인스턴스 변수를 Student2 에 포함시키는 것입니다 . 이러한 인스턴스
변수는 이름과 거주지 속성을 유지하는 데 사용되며, 교수진을 저장하는 데
사용되는 인스턴스 변수 Faculty 를 여기에 추가합니다.

[source,java]
----
public class Student2 {
private Person person;
private String faculty;

    public Student2(String name, String residence, String faculty) {
        person = new Person(name, residence);
        this.faculty = faculty;
    }

    public String getName() {
        return person.getName();
    }

    public String getResidence() {
        return person.getResidence();
    }

    public void setResidence(String residence) {
        person.setResidence(residence);
    }

    public String getFaculty() {
        return faculty;
    }
}
----

==== 메모:

* Student2 클래스는 Person 인스턴스 변수를 사용합니다 . Person 객체
  는 학생의 이름과 거주지를 저장합니다. Student2 는 Person 의
  클라이언트 이므로 Person 필드는 Person 클래스의 공개 메서드를 사용하여
  조작됩니다 .
* Student2 클래스는 클라이언트로부터 Person 객체의 사용을 완전히
  숨깁니다 . 실제로 Student2 개체 에서
  작동하는 getName , getResidence 및 setResidence 메서드를 클라이언트에
  제공합니다 .
* Student2 클래스는 클라이언트에게 Student 클래스와 동일한
  작업(메서드)을 제공합니다 . 그러나 Student2 개체는 Person 클래스의
  개체와 _호환되지 않습니다_ . 따라서 변수 또는 형식 매개변수가 Person
  유형(객체에 대한 참조)인 경우 Student2 객체(에 대한 참조)를 포함할 수
  없습니다 .

=== 3.58 상속 혹은 합성

* 이전 예를 참조하면 Student 대신 Student2 클래스를 구현하는
  것이 의심스러운 선택이라는 것이 분명합니다. 그렇다면 언제 합성을
  사용하는 것이 합리적일까요?
* 일반적으로 다음 기준을 채택할 수 있습니다.
  ** 일반적으로 다음 기준을 채택할 수 있습니다.
  ** _Y_ 의 각 객체에 _X_ 의 객체가 있는 경우 ( _Y_  HAS-A  _X_ ) 합성을
  사용합니다.
